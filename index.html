<!DOCTYPE html>
<html lang="pl" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ReflexCore - Profesjonalny Trener Celności i Reakcji</title>
    <meta name="description" content="Popraw swój czas reakcji, celność i szybkość pisania. Trenuj w wielu trybach gry: Aim Trainer, Tracking, Test Pisania, Gra Pamięciowa i Whac-a-Mole.">
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    
    <style>
        /* ======================================================================= */
        /* 1. GLOBALNE ZMIENNE CSS I RESETOWANIE                                   */
        /* ======================================================================= */

        /* Definiujemy zmienne CSS w :root, aby były globalnie dostępne  */
        :root {
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            --transition-speed: 0.3s;
            
            /* Zmienne dynamiczne dla gry (kontrolowane przez JS/Ustawienia)  */
            --target-size: 50px;
            --target-color: #FF4136; /* Czerwony */
            --target-color-hover: #FF7066;
        }

        /* --- Motyw Jasny (Domyślny) --- */
        [data-theme="light"] {
            --bg-color: #F8F9FA;          /* Bardzo jasny szary tła */
            --bg-color-secondary: #FFFFFF;    /* Biały dla paneli */
            --text-color: #212529;         /* Ciemny tekst */
            --text-color-muted: #6C757D;   /* Szary tekst */
            --border-color: #DEE2E6;       /* Jasny border */
            --accent-color: #007BFF;       /* Główny niebieski */
            --accent-color-hover: #0056b3;
            --danger-color: #DC3545;
            --danger-color-hover: #a71d2a;
            --success-color: #28A745;
        }

        /* --- Motyw Ciemny --- */
        [data-theme="dark"] {
            --bg-color: #121212;          /* Prawie czarne tło */
            --bg-color-secondary: #1E1E1E;    /* Ciemnoszary dla paneli */
            --text-color: #E0E0E0;         /* Jasny tekst */
            --text-color-muted: #8E8E8E;   /* Szary tekst */
            --border-color: #333333;       /* Ciemny border */
            --accent-color: #0D6EFD;       /* Jaśniejszy niebieski */
            --accent-color-hover: #3D8BFF;
            --danger-color: #FF4136;
            --danger-color-hover: #FF7066;
            --success-color: #198754;
        }

        /* --- Globalny Reset --- */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            /* Płynne przewijanie */
            scroll-behavior: smooth;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            transition: background-color var(--transition-speed), color var(--transition-speed);
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        h1, h2, h3, h4, h5, h6 {
            margin-bottom: 0.75rem;
            line-height: 1.2;
        }

        a {
            color: var(--accent-color);
            text-decoration: none;
            transition: color var(--transition-speed);
        }

        a:hover {
            color: var(--accent-color-hover);
            text-decoration: underline;
        }

        img {
            max-width: 100%;
            height: auto;
            display: block;
        }

        button,
        select,
        input {
            font-family: inherit;
            font-size: 1rem;
            color: inherit;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            padding: 0.5rem 0.75rem;
            background-color: var(--bg-color-secondary);
            transition: all var(--transition-speed);
        }

        button:hover {
            cursor: pointer;
        }

        .btn {
            border: none;
            color: #FFFFFF;
            background-color: var(--accent-color);
            font-weight: bold;
        }
        .btn:hover {
            background-color: var(--accent-color-hover);
        }
        .btn-danger {
            background-color: var(--danger-color);
        }
        .btn-danger:hover {
            background-color: var(--danger-color-hover);
        }
        .icon-btn {
            background: none;
            border: none;
            padding: 0.5rem;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .icon-btn:hover {
            background-color: var(--border-color);
        }
        .icon-btn svg {
            width: 24px;
            height: 24px;
            fill: var(--text-color);
        }

        /* ======================================================================= */
        /* 2. UKŁAD STRONY (HEADER, NAV, MAIN, SIDEBAR, FOOTER)                    */
        /* ======================================================================= */

        /* --- Nagłówek --- */
        .main-header {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 2rem;
            background-color: var(--bg-color-secondary);
            border-bottom: 2px solid var(--border-color);
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .logo {
            font-size: 2rem;
            font-weight: 800;
            color: var(--text-color);
        }
        .logo-accent {
            color: var(--accent-color);
        }
        .settings-toggle-container {
            display: flex;
            align-items: center;
        }

        /* --- Nawigacja --- */
        .main-nav {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.5rem;
            padding: 1rem;
            background-color: var(--bg-color-secondary);
            border-bottom: 1px solid var(--border-color);
        }
        .nav-btn {
            border: none;
            background: none;
            padding: 0.5rem 1rem;
            font-weight: 600;
            color: var(--text-color-muted);
            border-radius: 5px;
        }
        .nav-btn:hover {
            background-color: var(--border-color);
            color: var(--text-color);
        }
        .nav-btn.active {
            background-color: var(--accent-color);
            color: #FFFFFF;
        }

        /* --- Główny Układ Aplikacji (Grid) --- */
        .app-container {
            display: grid;
            /* Definiujemy 3 kolumny: Ustawienia (auto), Treść (1fr), Sidebar (auto) */
            grid-template-columns: auto 1fr auto;
            width: 100%;
            max-width: 1600px;
            margin: 1rem auto;
            padding: 0 1rem;
            gap: 1rem;
            flex-grow: 1;
        }

        /* --- Panel Ustawień --- */
        .settings-panel {
            grid-column: 1 / 2;
            background-color: var(--bg-color-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            width: 280px;
            align-self: start; /* Przyklejony do góry */
            transition: all 0.3s ease-in-out;
        }
        /* Logika pokazywania/ukrywania panelu */
        .settings-panel[hidden] {
            display: block!important; /* Pozwalamy na animację */
            transform: translateX(-100%);
            opacity: 0;
            width: 0;
            padding: 1rem 0;
            margin-right: -1rem; /* Kompensacja 'gap' */
        }
        .settings-panel.open {
            transform: translateX(0);
            opacity: 1;
            width: 280px;
            padding: 1rem;
            margin-right: 0;
        }
        .settings-title,.settings-subtitle {
            border-bottom: 2px solid var(--accent-color);
            padding-bottom: 0.5rem;
            margin-bottom: 1rem;
        }
        .settings-subtitle {
            font-size: 1.1rem;
            margin-top: 1rem;
        }
        .setting-group {
            margin-bottom: 1.25rem;
        }
        .setting-label {
            display: block;
            font-weight: 600;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }
        .setting-select,.setting-slider,.setting-color-picker {
            width: 100%;
        }
        .setting-color-picker {
            height: 40px;
            padding: 0.25rem;
            border: 1px solid var(--border-color);
        }

        /* --- Przełącznik Motywu (Toggle Switch) --- */
        .toggle-switch {
            position: relative;
            width: 100px;
            height: 40px;
        }
        .toggle-input {
            display: none;
        }
        .toggle-label {
            display: block;
            width: 100px;
            height: 40px;
            background-color: var(--bg-color-secondary);
            border: 2px solid var(--border-color);
            border-radius: 20px;
            cursor: pointer;
            position: relative;
            transition: all var(--transition-speed);
        }
        .toggle-label::before {
            content: '';
            display: block;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background-color: var(--accent-color);
            position: absolute;
            top: 2px;
            left: 4px;
            transition: all var(--transition-speed) ease-in-out;
        }
        .toggle-text-light,.toggle-text-dark {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.8rem;
            font-weight: bold;
        }
        .toggle-text-light {
            left: 10px;
            color: var(--text-color);
        }
        .toggle-text-dark {
            right: 10px;
            color: var(--text-color-muted);
        }
        /* Stan "Ciemny" (zaznaczony) */
        .toggle-input:checked +.toggle-label {
            background-color: var(--bg-color-secondary);
        }
        .toggle-input:checked +.toggle-label::before {
            transform: translateX(60px); /* Przesunięcie kulki */
            background-color: var(--accent-color);
        }
        .toggle-input:checked +.toggle-label .toggle-text-light {
            color: var(--text-color-muted);
        }
        .toggle-input:checked +.toggle-label .toggle-text-dark {
            color: var(--text-color);
        }


        /* --- Główna Treść --- */
        .main-content {
            grid-column: 2 / 3;
            background-color: var(--bg-color-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 2rem;
            min-height: 70vh; /* Minimalna wysokość, aby strona wyglądała dobrze */
        }
        .game-screen {
            display: none; /* Domyślnie ukryte */
            flex-direction: column;
            align-items: center;
        }
        .game-screen.active {
            display: flex; /* Pokazujemy only aktywny ekran */
        }
        .game-title,.game-subtitle {
            text-align: center;
        }
        .game-description {
            text-align: center;
            font-size: 1.1rem;
            color: var(--text-color-muted);
            margin-bottom: 1.5rem;
        }
        .high-scores {
            width: 100%;
            max-width: 400px;
            margin-top: 1rem;
        }

        /* --- Panel Boczny (Sidebar) --- */
        .sidebar {
            grid-column: 3 / 4;
            background-color: var(--bg-color-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            width: 200px;
            align-self: start;
        }
        .widget-title {
            font-size: 1.2rem;
            border-bottom: 2px solid var(--accent-color);
            padding-bottom: 0.5rem;
            margin-bottom: 1rem;
        }
        .stat-item {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }
        .stat-label {
            font-weight: 600;
            color: var(--text-color-muted);
        }
        .stat-value {
            font-weight: bold;
        }

        /* --- Stopka --- */
        .main-footer {
            width: 100%;
            padding: 2rem;
            margin-top: auto; /* Przykleja stopkę na dole */
            text-align: center;
            background-color: var(--bg-color-secondary);
            border-top: 1px solid var(--border-color);
            font-size: 0.9rem;
            color: var(--text-color-muted);
        }

        /* ======================================================================= */
        /* 3. STYLE DLA REKLAM (KLUCZOWE DLA ZGODNOŚCI)                            */
        /* ======================================================================= */

        .ad-container {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--bg-color);
            border: 1px dashed var(--border-color);
            min-height: 50px; /* Minimalna wysokość dla bannerów */
            margin: 1rem 0;
        }

        /* Etykieta "Advertisement"
          Jest to WYMÓG Google AdSense, aby wyraźnie oddzielić reklamy od treści.
          Zapobiega to karom za "mylący układ".[19]
        */
        .ad-label {
            position: absolute;
            top: -1px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--border-color);
            color: var(--text-color-muted);
            padding: 2px 8px;
            font-size: 10px;
            font-weight: bold;
            text-transform: uppercase;
            border-radius: 0 0 5px 5px;
            z-index: 1;
        }

        /* Tekst zastępczy (placeholder) dla pustych slotów */
        .ad-placeholder-text {
            font-size: 0.9rem;
            color: var(--text-color-muted);
            font-weight: 500;
        }

        /* Style dla specyficznych slotów */
        .header-ad-container {
            display: flex;
            gap: 1rem;
        }
        .ad-container-top-banner {
            width: 300px; /* Można dostosować */
            height: 50px;
            margin: 0; /* Bez marginesu w nagłówku */
        }
        .ad-container-google-middle {
            width: 100%;
            max-width: 336px;
            min-height: 280px;
            margin: 2rem auto; /* Wyraźne oddzielenie */
        }
        .ad-container-sidebar {
            width: 100%;
            min-height: 250px; /* Domyślnie, dostosuje się do 160x600 */
        }

        /* ======================================================================= */
        /* 4. STYLE DLA MODALI (OKNA DIALOGOWE)                                    */
        /* ======================================================================= */

        /* Stylizacja natywnego elementu <dialog>  
          i jego tła (backdrop)
        */
        .modal {
            border: none;
            border-radius: 8px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
            padding: 0; /* Usuwamy domyślny padding */
            width: 90%;
            max-width: 500px;
            background: var(--bg-color-secondary);
            color: var(--text-color);
        }
        /* Tło za modalem */
        .modal::backdrop {
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(3px);
        }
        .modal-content {
            padding: 1.5rem;
            position: relative;
        }
        .modal-close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 2rem;
            font-weight: bold;
            color: var(--text-color-muted);
            padding: 0 0.5rem;
        }
        .modal-close-btn:hover {
            color: var(--danger-color);
        }
        .modal-title {
            font-size: 1.8rem;
            margin-bottom: 1rem;
            color: var(--accent-color);
        }
        .modal-body {
            margin-bottom: 1.5rem;
        }
        .modal-body p {
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
        }
        .modal-footer {
            display: flex;
            justify-content: flex-end;
        }
        .new-highscore {
            color: var(--success-color);
            text-align: center;
            font-size: 1.3rem;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        /* Specjalne style dla modala reklamowego */
        .modal-ad .modal-content {
            padding: 0;
        }
        .modal-ad .modal-title {
            /* Etykieta AdSense wewnątrz modala */
            text-align: center;
            font-size: 1rem;
            padding: 0.5rem;
            background: var(--bg-color);
            margin-bottom: 0;
            color: var(--text-color-muted);
        }
        .modal-ad .modal-body {
            padding: 1rem;
            margin-bottom: 0;
        }
        .modal-ad .ad-container {
            margin: 0;
            border: none;
            background: none;
        }
        .modal-ad .ad-sub-text {
            font-size: 0.9rem;
            text-align: center;
            color: var(--text-color-muted);
            margin-top: 1rem;
            margin-bottom: 0;
        }


        /* ======================================================================= */
        /* 5. STYLE DLA TRYBÓW GRY (AIM TRAINER, TYPING, MEMORY...)                 */
        /* ======================================================================= */

        /* --- Kontener Gry --- */
        .game-area {
            width: 100%;
            height: 60vh; /* 60% wysokości widoku */
            min-height: 400px;
            background-color: var(--bg-color);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            position: relative; /* Kluczowe dla pozycjonowania celów */
            overflow: hidden;
            cursor: crosshair;
            user-select: none; /* Zapobiega zaznaczaniu tekstu podczas gry */
        }
        .game-start-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            padding: 2rem;
            text-align: center;
        }
        .game-start-screen .game-title {
            color: var(--accent-color);
        }
        .game-start-screen .btn {
            font-size: 1.5rem;
            padding: 1rem 2rem;
            margin-top: 1rem;
        }

        /* --- Cel (Aim Trainer & Tracking) --- */
        .target {
            /* Używamy zmiennych CSS do dynamicznej kontroli  */
            width: var(--target-size);
            height: var(--target-size);
            background-color: var(--target-color);
            border-radius: 50%;
            position: absolute;
            cursor: crosshair;
            transition: transform 0.1s ease-out, background-color 0.1s;
            box-shadow: 0 0 15px var(--target-color);
        }
        .target:hover {
            background-color: var(--target-color-hover);
            transform: scale(1.1);
        }

        /* --- Test Pisania (Typing Test) --- */
        .typing-test-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .typing-stats {
            display: flex;
            justify-content: space-around;
            padding: 1rem;
            background-color: var(--bg-color);
            border-radius: 8px;
        }
        .typing-stat-item {
            text-align: center;
        }
        .typing-stat-label {
            font-size: 0.9rem;
            color: var(--text-color-muted);
        }
        .typing-stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: var(--accent-color);
        }
        .typing-text-display {
            font-family: 'Courier New', Courier, monospace;
            font-size: 1.5rem;
            line-height: 2;
            padding: 1.5rem;
            background-color: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            height: 250px;
            overflow-y: auto;
            user-select: none;
        }
        .typing-text-display span {
            transition: color 0.1s, background-color 0.1s;
        }
        .typing-text-display span.correct {
            color: var(--success-color);
        }
        .typing-text-display span.incorrect {
            color: var(--danger-color);
            background-color: rgba(220, 53, 69, 0.1);
            text-decoration: underline;
        }
        .typing-text-display span.current {
            background-color: var(--accent-color);
            color: #FFFFFF;
            border-radius: 2px;
        }
        .typing-input-area {
            width: 100%;
            font-size: 1.5rem;
            font-family: 'Courier New', Courier, monospace;
            padding: 1rem;
            border: 2px solid var(--accent-color);
        }
        .typing-input-area:focus {
            outline: none;
            box-shadow: 0 0 10px var(--accent-color);
        }
        .typing-restart-btn {
            font-size: 1.2rem;
            padding: 0.75rem 1.5rem;
            align-self: center;
        }

        /* --- Gra Pamięciowa (Memory Game) --- */
        .memory-game-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            width: 100%;
            max-width: 500px;
            margin: 0 auto;
            perspective: 1000px; /* Dla efektu 3D */
        }
        .memory-card {
            width: 100%;
            aspect-ratio: 1 / 1; /* Idealny kwadrat */
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s;
            cursor: pointer;
        }
        .memory-card.flip {
            transform: rotateY(180deg);
        }
        .memory-card .front-face,
        .memory-card .back-face {
            width: 100%;
            height: 100%;
            position: absolute;
            backface-visibility: hidden; 
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .memory-card .front-face {
            background-color: var(--bg-color-secondary);
            border: 2px solid var(--border-color);
            color: var(--text-color);
            transform: rotateY(180deg);
        }
        .memory-card .back-face {
            background: linear-gradient(135deg, var(--accent-color), var(--accent-color-hover));
            color: #FFFFFF;
            font-weight: bold;
        }

        /* --- Gra Whac-a-Mole --- */
        .whac-game-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            width: 100%;
            max-width: 450px;
            margin: 2rem auto;
        }
        .whac-hole {
            width: 100%;
            aspect-ratio: 1 / 1;
            background-color: #A0522D; /* Kolor ziemi */
            border-radius: 50%;
            position: relative;
            overflow: hidden;
            border: 10px solid #8B4513;
            box-shadow: inset 0 10px 10px rgba(0,0,0,0.3);
        }
        .whac-mole {
            width: 70%;
            height: 70%;
            background-color: #D2B48C; /* Kolor kreta */
            border: 3px solid #000;
            border-radius: 50%;
            position: absolute;
            bottom: 0;
            left: 15%;
            transition: transform 0.2s ease-out;
            transform: translateY(100%); /* Schowany */
            cursor: pointer;
        }
        .whac-hole.up .whac-mole {
            transform: translateY(0); /* Wysunięty */
        }


        /* ======================================================================= */
        /* 6. RESPONSIVE WEB DESIGN (RWD)                                          */
        /* ======================================================================= */

        @media (max-width: 1200px) {
           .app-container {
                /* Przenosimy sidebar pod treść, jeśli ustawienia są otwarte */
                grid-template-columns: auto 1fr;
            }
           .sidebar {
                grid-column: 1 / 3; /* Zajmuje całą szerokość */
                grid-row: 3 / 4; /* Pod treścią */
                width: 100%;
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 1rem;
            }
           .ad-container-sidebar {
                /* Zmieniamy Skyscraper na bardziej odpowiedni format */
                min-height: 250px; 
            }
           .main-content {
                /* Jeśli ustawienia są otwarte */
                grid-column: 2 / 3;
            }
           .main-content.full-width {
                /* Jeśli ustawienia są zamknięte */
                grid-column: 1 / 3;
            }
        }

        @media (max-width: 768px) {
           .app-container {
                /* Ustawienia i treść w jednej kolumnie */
                grid-template-columns: 1fr;
                margin: 0.5rem auto;
                padding: 0 0.5rem;
            }
           .settings-panel {
                grid-column: 1 / 2;
                grid-row: 1 / 2;
                width: 100%;
                /* Ukrywanie/Pokaż na mobilkach */
                max-height: 0;
                padding: 0 1rem;
                border: none;
                overflow: hidden;
                opacity: 0;
                transform: translateY(-20px);
                transition: all 0.3s ease-in-out;
            }
           .settings-panel.open {
                max-height: 1000px; /* Wystarczająco dużo */
                padding: 1rem;
                opacity: 1;
                transform: translateY(0);
                border: 1px solid var(--border-color);
            }
           .main-content,.main-content.full-width {
                grid-column: 1 / 2;
                grid-row: 2 / 3;
                padding: 1rem;
                min-height: 60vh;
            }
           .sidebar {
                grid-column: 1 / 2;
                grid-row: 3 / 4;
                grid-template-columns: 1fr; /* Statystyki i reklama jedna pod drugą */
            }
           .main-header {
                padding: 1rem;
                flex-direction: column;
                gap: 1rem;
            }
           .header-ad-container {
                width: 100%;
                justify-content: center;
            }
            
            /* KRYTYCZNA REGUŁA ZGODNOŚCI Z ADSENSE 
              Polityka Google zaleca tylko jedną jednostkę ATF na mobilkach.
              Ukrywamy jedną z dwóch reklam z nagłówka, aby zachować zgodność.
            */
            #ad-header-top-right {
                display: none;
            }
           .ad-container-top-banner {
                width: 100%;
                max-width: 320px;
            }
            
           .main-nav {
                /* Pozwalamy przyciskom zawijać się i centrować */
                gap: 0.25rem;
                padding: 0.5rem;
            }
           .nav-btn {
                font-size: 0.85rem;
                padding: 0.5rem 0.75rem;
            }
            
           .modal {
                width: 95%;
            }
            
           .game-area {
                min-height: 300px;
                height: 50vh;
            }
            
           .memory-game-grid {
                gap: 5px;
            }
           .whac-game-grid {
                gap: 10px;
            }
        } 
    </style>

</head>
<body>

    <header class="main-header">
        <div class="logo-container">
            <h1 class="logo">Reflex<span class="logo-accent">Core</span></h1>
        </div>
        
        <div class="header-ad-container">
            <div id="ad-header-top-left" class="ad-container ad-container-top-banner">
                <div class="ad-label">Advertisement</div>
                <div class="ad-placeholder-text"></div>
            </div>
            
            <div id="ad-header-top-right" class="ad-container ad-container-top-banner">
                <div class="ad-label">Advertisement</div>
                <div class="ad-placeholder-text"></div>
            </div>
        </div>
        
        <div class="settings-toggle-container">
            <button id="settings-toggle-btn" class="icon-btn" aria-label="Otwórz ustawienia">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M19.826 12.0001C19.826 13.3854 19.4533 14.7127 18.7613 15.8642L20.552 17.6549C20.7473 17.8502 20.7473 18.1668 20.552 18.362L19.138 19.776C18.9427 19.9713 18.6261 19.9713 18.4308 19.776L16.6117 17.9568C15.5393 18.5714 14.321 18.9664 13.0001 19.0833V21.0963C13.0001 21.3745 12.7762 21.5984 12.498 21.5984L11.5022 21.5984C11.224 21.5984 11.0001 21.3745 11.0001 21.0963V19.0833C9.67916 18.9664 8.46089 18.5714 7.38848 17.9568L5.56937 19.776C5.37407 19.9713 5.05748 19.9713 4.86218 19.776L3.44818 18.362C3.25288 18.1668 3.25288 17.8502 3.44818 17.6549L5.23889 15.8642C4.54694 14.7127 4.1742 13.3854 4.1742 12.0001C4.1742 10.6147 4.54694 9.28746 5.23889 8.13592L3.44818 6.34521C3.25288 6.14991 3.25288 5.83332 3.44818 5.63802L4.86218 4.22402C5.05748 4.02872 5.37407 4.02872 5.56937 4.22402L7.38848 6.04313C8.46089 5.42854 9.67916 5.03357 11.0001 5.00013V2.90381C11.0001 2.62564 11.224 2.40173 11.5022 2.40173L12.498 2.40173C12.7762 2.40173 13.0001 2.62564 13.0001 2.90381V5.00013C14.321 5.03357 15.5393 5.42854 16.6117 6.04313L18.4308 4.22402C18.6261 4.02872 18.9427 4.02872 19.138 4.22402L20.552 5.63802C20.7473 5.83332 20.7473 6.14991 20.552 6.34521L18.7613 8.13592C19.4533 9.28746 19.826 10.6147 19.826 12.0001ZM12.0001 15.5C13.9331 15.5 15.5001 13.933 15.5001 12C15.5001 10.067 13.9331 8.5 12.0001 8.5C10.0671 8.5 8.50008 10.067 8.50008 12C8.50008 13.933 10.0671 15.5 12.0001 15.5Z"></path></svg>
            </button>
        </div>
    </header>

    <nav class="main-nav">
        <button class="nav-btn active" data-game="aimTrainer">Trener Celności</button>
        <button class="nav-btn" data-game="tracking">Śledzenie (Tracking)</button>
        <button class="nav-btn" data-game="typingTest">Test Pisania (WPM)</button>
        <button class="nav-btn" data-game="memoryGame">Gra Pamięciowa</button>
        <button class="nav-btn" data-game="whacAMole">Whac-a-Mole</button>
        <button class="nav-btn" data-section="blog">Blog / Poradniki</button>
        <button class="nav-btn" data-section="faq">FAQ</button>
    </nav>

    <div class="app-container">
    
        <aside id="settings-panel" class="settings-panel" hidden>
            <h2 class="settings-title">Ustawienia</h2>
            
            <div class="setting-group">
                <label for="theme-toggle" class="setting-label">Motyw Strony</label>
                <div class="toggle-switch">
                    <input type="checkbox" id="theme-toggle" class="toggle-input">
                    <label for="theme-toggle" class="toggle-label">
                        <span class="toggle-text-light">Jasny</span>
                        <span class="toggle-text-dark">Ciemny</span>
                    </label>
                </div>
            </div>
            
            <div class="setting-group">
                <label for="language-select" class="setting-label">Język</label>
                <select id="language-select" class="setting-select">
                    <option value="pl">Polski</option>
                    <option value="en">English</option>
                </select>
            </div>
            
            <hr class="settings-divider">
            <h3 class="settings-subtitle">Ustawienia Gry (Aim Trainer)</h3>
            
            <div class="setting-group">
                <label for="target-size-slider" class="setting-label">Rozmiar Celu: <span id="target-size-value">50</span>px</label>
                <input type="range" id="target-size-slider" class="setting-slider" min="10" max="100" value="50" data-css-var="--target-size">
            </div>
            
            <div class="setting-group">
                <label for="target-color-picker" class="setting-label">Kolor Celu</label>
                <input type="color" id="target-color-picker" class="setting-color-picker" value="#FF4136" data-css-var="--target-color">
            </div>
            
            <div class="setting-group">
                <button id="reset-stats-btn" class="btn btn-danger">Zresetuj Najlepsze Wyniki</button>
            </div>
            
        </aside>

        <main id="main-content" class="main-content">
        
            <div id="welcome-screen" class="game-screen active">
                <h2 class="game-title">Witaj w ReflexCore</h2>
                <p class="game-description">Wybierz tryb gry z nawigacji powyżej, aby rozpocząć trening.</p>
                
                <div id="ad-google-middle" class="ad-container ad-container-google-middle">
                    <div class="ad-label">Advertisement</div>
                    <div class="ad-placeholder-text"></div>
                </div>
                
                <h3 class="game-subtitle">Twoje Najlepsze Wyniki</h3>
                <div id="high-scores-display" class="high-scores">
                    <p>Ładowanie wyników...</p>
                </div>
            </div>

            <div id="game-container" class="game-container">
                </div>
            
            <div id="static-content-container" class="static-content" hidden>
                </div>
            
        </main>
        
        <aside class="sidebar">
            <div class="sidebar-widget">
                <h3 class="widget-title">Statystyki Live</h3>
                <div id="live-stats" class="live-stats">
                    <div class="stat-item">
                        <span class="stat-label">Trafienia:</span>
                        <span id="stat-hits" class="stat-value">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Pudła:</span>
                        <span id="stat-misses" class="stat-value">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Celność:</span>
                        <span id="stat-accuracy" class="stat-value">0%</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Czas:</span>
                        <span id="stat-timer" class="stat-value">0.0s</span>
                    </div>
                </div>
            </div>
            
            <div id="ad-sidebar-skyscraper" class="ad-container ad-container-sidebar">
                 <div class="ad-label">Advertisement</div>
                 <div class="ad-placeholder-text"></div>
            </div>
        </aside>
    </div>

    <footer class="main-footer">
        <p>&copy; 2025 ReflexCore. Wszelkie prawa zastrzeżone.</p>
        <p>
            <a href="/privacy.html">Polityka Prywatności</a> | 
            <a href="/terms.html">Warunki Użytkowania</a>
        </p>
    </footer>

    <dialog id="stats-modal" class="modal">
        <div class="modal-content">
            <button class="modal-close-btn" data-close-modal="stats-modal" aria-label="Zamknij okno statystyk">&times;</button>
            <h2 id="modal-title" class="modal-title">Gra Zakończona!</h2>
            <div id="modal-body" class="modal-body">
                <p>Średni czas reakcji: <span id="final-avg-reaction">0</span> ms</p>
                <p>Trafienia: <span id="final-hits">0</span></p>
                <p>Pudła: <span id="final-misses">0</span></p>
                <p>Celność: <span id="final-accuracy">0</span>%</p>
                <p>CPS: <span id="final-cps">0</span></p>
                <h3 id="final-new-highscore" class="new-highscore" hidden>Nowy Rekord!</h3>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" data-close-modal="stats-modal">Zamknij</button>
            </div>
        </div>
    </dialog>
    
    <dialog id="ad-notification-modal" class="modal modal-ad">
        <div class="modal-content">
            <button class="modal-close-btn" data-close-modal="ad-notification-modal" aria-label="Zamknij reklamę">&times;</button>
            <h2 class="modal-title ad-label">Advertisement</h2>
            <div id="ad-notification-content" class="modal-body">
                <div class="ad-placeholder-text"></div>
                <p class="ad-sub-text">Gra rozpocznie się za chwilę...</p>
            </div>
        </div>
    </dialog>

    <script>
        /*
        =======================================================================
         GŁÓWNY PLIK APLIKACJI: ReflexCore v1.0
         Całkowita długość kodu: > 2000 linii
         
         Spis Treści:
         1. Moduł 1: Inicjalizacja, Stan Aplikacji i Selektory DOM
         2. Moduł 2: Zarządzanie Ustawieniami (Motyw, Język, Gra)
         3. Moduł 3: Zarządzanie Interfejsem (Nawigacja, Modale)
         4. Moduł 4: Zarządzanie Danymi (LocalStorage, Wyniki)
         5. Moduł 5: Tryb Gry - Trener Celności (Aim Trainer)
         6. Moduł 6: Tryb Gry - Śledzenie (Tracking)
         7. Moduł 7: Tryb Gry - Test Szybkiego Pisania (Typing Test)
         8. Moduł 8: Tryb Gry - Gra Pamięciowa (Memory Game)
         9. Moduł 9: Tryb Gry - Whac-a-Mole
         10. Moduł 10: Inicjalizacja Aplikacji (Główna Pętla)
        =======================================================================
        */

        // Używamy "strict mode" dla lepszej jakości kodu i unikania cichych błędów
        'use strict';

        /*
        =======================================================================
         1. Moduł 1: Inicjalizacja, Stan Aplikacji i Selektory DOM
        =======================================================================
        */

        // Obiekt przechowujący globalny stan aplikacji
        const AppState = {
            // Przechowuje referencje do wszystkich kluczowych elementów DOM
            // Pozwala to na uniknięcie wielokrotnego odwoływania się do document.querySelector
            DOM: {},
            
            // Przechowuje ustawienia użytkownika (ładowane z localStorage)
            settings: {
                theme: 'light',
                language: 'pl',
                gameSettings: {
                    '--target-size': 50, // Wartość domyślna
                    '--target-color': '#FF4136' // Wartość domyślna
                }
            },
            
            // Przechowuje statystyki i timery dla aktualnie aktywnej gry
            currentGame: {
                isActive: false,
                gameMode: null,      // np. 'aimTrainer', 'typingTest'
                timerInterval: null,
                startTime: 0,
                endTime: 0,
                hits: 0,
                misses: 0,
                reactionTimes: [], // Tablica do przechowywania czasów reakcji [31]
                lastReactionTime: 0,
                cpsCounter: {
                    clicks: 0,
                    timer: null,
                    isMeasuring: false
                },
                accuracy: 0 // Dodane dla testu pisania
            },
            
            // Przechowuje najlepsze wyniki (ładowane z localStorage)
            highScores: {}
        };

        /**
         * Funkcja inicjalizująca selektory DOM.
         * Wywoływana jeden raz po załadowaniu drzewa DOM.
         */
        function initializeDOMSelectors() {
            const D = AppState.DOM; // Skrót
            
            // Główne kontenery
            D.mainContent = document.getElementById('main-content');
            D.gameContainer = document.getElementById('game-container');
            D.staticContentContainer = document.getElementById('static-content-container');
            D.welcomeScreen = document.getElementById('welcome-screen');
            
            // Nawigacja
            D.mainNav = document.querySelector('.main-nav');
            D.navButtons = document.querySelectorAll('.nav-btn');
            
            // Panel Ustawień
            D.settingsPanel = document.getElementById('settings-panel');
            D.settingsToggleBtn = document.getElementById('settings-toggle-btn');
            D.themeToggle = document.getElementById('theme-toggle');
            D.languageSelect = document.getElementById('language-select');
            D.targetSizeSlider = document.getElementById('target-size-slider');
            D.targetSizeValue = document.getElementById('target-size-value');
            D.targetColorPicker = document.getElementById('target-color-picker');
            D.resetStatsBtn = document.getElementById('reset-stats-btn');
            
            // Statystyki na żywo (Sidebar)
            D.liveStats = {
                hits: document.getElementById('stat-hits'),
                misses: document.getElementById('stat-misses'),
                accuracy: document.getElementById('stat-accuracy'),
                timer: document.getElementById('stat-timer')
            };
            
            // Modal Statystyk Końcowych
            D.statsModal = document.getElementById('stats-modal');
            D.statsModalTitle = document.getElementById('modal-title');
            D.statsModalBody = document.getElementById('modal-body');
            D.statsModalNewHighScore = document.getElementById('final-new-highscore');
            D.statsModalCloseBtns = document.querySelectorAll('[data-close-modal="stats-modal"]');
            
            // Modal Reklamy (Powiadomienie)
            D.adNotificationModal = document.getElementById('ad-notification-modal');
            D.adNotificationModalCloseBtns = document.querySelectorAll('[data-close-modal="ad-notification-modal"]');
            
            // Wyświetlanie Najlepszych Wyników
            D.highScoresDisplay = document.getElementById('high-scores-display');
            
            // Referencja do :root dla zmiennych CSS 
            D.root = document.documentElement;
        }


        /*
        =======================================================================
         2. Moduł 2: Zarządzanie Ustawieniami (Motyw, Język, Gra)
            - Naprawa zgłoszonego błędu przełączania motywu.
            - Użycie architektury opartej na Zmiennych CSS.[7, 6]
        =======================================================================
        */

        /**
         * Inicjalizuje event listenery dla panelu ustawień.
         */
        function initializeSettingsPanel() {
            const D = AppState.DOM;

            // Przełącznik otwierania/zamykania panelu
            D.settingsToggleBtn.addEventListener('click', toggleSettingsPanel);
            
            // Przełącznik Motywu
            D.themeToggle.addEventListener('change', handleThemeChange);
            
            // Przełącznik Języka (obecnie tylko placeholder, wymaga implementacji i18n)
            D.languageSelect.addEventListener('change', handleLanguageChange);
            
            // Suwak Rozmiaru Celu
            D.targetSizeSlider.addEventListener('input', handleGameSettingChange);
            
            // Wybór Koloru Celu
            D.targetColorPicker.addEventListener('input', handleGameSettingChange);
            
            // Resetowanie Statystyk
            D.resetStatsBtn.addEventListener('click', handleResetHighScores);
        }

        /**
         * Pokazuje lub ukrywa panel ustawień.
         */
        function toggleSettingsPanel() {
            const D = AppState.DOM;
            const isOpen = D.settingsPanel.classList.toggle('open');
            D.settingsPanel.hidden = !isOpen;
            
            // Dostosowanie szerokości głównej treści dla lepszego RWD
            if (window.innerWidth < 1200) { // Na mobilkach/tabletach nie zmieniamy layoutu
                // Na większych ekranach
                D.mainContent.classList.toggle('full-width', !isOpen);
            }
            
            // Ustawienia ARIA dla dostępności
            D.settingsToggleBtn.setAttribute('aria-expanded', isOpen.toString());
            D.settingsPanel.setAttribute('aria-hidden', (!isOpen).toString());
        }

        /**
         * Obsługuje zmianę motywu (Jasny/Ciemny).
         * @param {Event} e - Zdarzenie 'change' z przełącznika.
         */
        function handleThemeChange(e) {
            const newTheme = e.target.checked ? 'dark' : 'light';
            applyTheme(newTheme);
            saveSetting('theme', newTheme);
        }

        /**
         * Aplikuje wybrany motyw, zmieniając atrybut na tagu <html>.
         * @param {string} themeName - Nazwa motywu ('light' lub 'dark').
         */
        function applyTheme(themeName) {
            AppState.DOM.root.setAttribute('data-theme', themeName);
            AppState.settings.theme = themeName;
            
            // Ustawia stan przełącznika zgodnie z załadowanym motywem
            if (AppState.DOM.themeToggle) {
                AppState.DOM.themeToggle.checked = (themeName === 'dark');
            }
        }

        /**
         * Obsługuje zmianę języka.
         * @param {Event} e - Zdarzenie 'change' z selektora.
         */
        function handleLanguageChange(e) {
            const newLang = e.target.value;
            applyLanguage(newLang);
            saveSetting('language', newLang);
        }

        /**
         * Aplikuje wybrany język (logika i18n do rozbudowy).
         * @param {string} langCode - Kod języka ('pl' lub 'en').
         */
        function applyLanguage(langCode) {
            AppState.DOM.root.setAttribute('lang', langCode);
            AppState.settings.language = langCode;
            console.log(`Język zmieniony na: ${langCode}. (Wymagana pełna implementacja i18n)`);
            // Tutaj należałoby zaimplementować podmianę wszystkich tekstów na stronie
            // np. na podstawie obiektu JSON z tłumaczeniami.
        }

        /**
         * Obsługuje zmianę ustawień gry (suwaki, kolory).
         * Używa .setProperty do dynamicznej zmiany zmiennych CSS.
         * @param {Event} e - Zdarzenie 'input' z suwaka lub wyboru koloru.
         */
        function handleGameSettingChange(e) {
            const D = AppState.DOM;
            const element = e.target;
            const cssVar = element.dataset.cssVar; // np. '--target-size'
            let value = element.value;

            if (!cssVar) return;

            // Jeśli to suwak, dodaj 'px' i zaktualizuj etykietę
            if (element.type === 'range') {
                const unit = 'px';
                value = `${value}${unit}`;
                
                // Aktualizacja etykiety (np. "Rozmiar Celu: 50px")
                if (cssVar === '--target-size' && D.targetSizeValue) {
                    D.targetSizeValue.textContent = element.value;
                }
            }
            
            // Dynamiczna zmiana zmiennej CSS 
            D.root.style.setProperty(cssVar, value);
            
            // Zapisz w obiekcie ustawień
            AppState.settings.gameSettings[cssVar] = element.value;
            saveSetting('gameSettings', AppState.settings.gameSettings);
        }

        /**
         * Aplikuje zapisane ustawienia gry (np. rozmiar celu) podczas ładowania.
         */
        function applySavedGameSettings() {
            const D = AppState.DOM;
            const settings = AppState.settings.gameSettings;
            
            for (const cssVar in settings) {
                const value = settings[cssVar];
                let valueWithUnit = value;
                
                // Aktualizacja suwaka i etykiety
                if (cssVar === '--target-size' && D.targetSizeSlider) {
                    D.targetSizeSlider.value = value;
                    D.targetSizeValue.textContent = value;
                    valueWithUnit = `${value}px`;
                }
                
                // Aktualizacja wyboru koloru
                if (cssVar === '--target-color' && D.targetColorPicker) {
                    D.targetColorPicker.value = value;
                }
                
                // Zastosuj zmienną CSS
                D.root.style.setProperty(cssVar, valueWithUnit);
            }
        }


        /*
        =======================================================================
         3. Moduł 3: Zarządzanie Interfejsem (Nawigacja, Modale)
            - Implementacja przełączania ekranów gier.
            - Implementacja zgodnych z ARIA okien modalnych.
        =======================================================================
        */

        /**
         * Inicjalizuje główną nawigację (przełączanie trybów gry).
         */
        function initializeNavigation() {
            const D = AppState.DOM;
            D.mainNav.addEventListener('click', (e) => {
                const target = e.target.closest('.nav-btn');
                if (!target) return;
                
                // Usunięcie aktywnej klasy ze wszystkich przycisków
                D.navButtons.forEach(btn => btn.classList.remove('active'));
                // Dodanie aktywnej klasy do klikniętego
                target.classList.add('active');
                
                const gameMode = target.dataset.game;
                const section = target.dataset.section;
                
                if (gameMode) {
                    // Przełącz na tryb gry
                    showGameScreen(gameMode);
                } else if (section) {
                    // Przełącz na sekcję statyczną (Blog/FAQ)
                    showStaticScreen(section);
                }
            });
        }

        /**
         * Pokazuje odpowiedni ekran gry i ukrywa inne.
         * @param {string} gameMode - ID trybu gry (np. 'aimTrainer').
         */
        function showGameScreen(gameMode) {
            const D = AppState.DOM;
            
            // Zatrzymaj poprzednią grę, jeśli jakaś była aktywna
            stopCurrentGame();
            
            // Ukryj ekran powitalny i kontener statyczny
            D.welcomeScreen.classList.remove('active');
            D.staticContentContainer.hidden = true;
            
            // Wyczyść kontener gry
            D.gameContainer.innerHTML = '';
            D.gameContainer.hidden = false;
            
            // Zresetuj statystyki na żywo
            resetLiveStats();
            
            let title, description, buttonText;
            
            // Wygeneruj HTML dla ekranu startowego wybranej gry
            switch (gameMode) {
                case 'aimTrainer':
                    title = 'Trener Celności';
                    description = 'Kliknij jak najwięcej celów w ciągu 30 sekund. Liczy się szybkość i precyzja.';
                    buttonText = 'Start (Aim Trainer)';
                    break;
                case 'tracking':
                    title = 'Trening Śledzenia (Tracking)';
                    description = 'Utrzymaj kursor na ruchomym celu tak długo, jak potrafisz. Gra trwa 30 sekund.';
                    buttonText = 'Start (Tracking)';
                    break;
                case 'typingTest':
                    title = 'Test Szybkiego Pisania (WPM)';
                    description = 'Zmierz swoją szybkość pisania (Słowa Na Minutę). Przepisz podany tekst tak szybko i dokładnie, jak potrafisz. Test trwa 60 sekund.';
                    buttonText = 'Rozpocznij Test Pisania';
                    break;
                case 'memoryGame':
                    title = 'Gra Pamięciowa';
                    description = 'Odszukaj wszystkie pasujące do siebie pary kart. Postaraj się zrobić to w jak najmniejszej liczbie ruchów.';
                    buttonText = 'Start (Memory)';
                    break;
                case 'whacAMole':
                    title = 'Whac-a-Mole';
                    description = 'Uderzaj pojawiające się krety! Gra trwa 30 sekund. Uważaj na pomyłki!';
                    buttonText = 'Start (Whac-a-Mole)';
                    break;
                default:
                    return;
            }
            
            // Specjalna obsługa dla gier, które nie mają ekranu "Start" (jak memory lub typing)
            if (gameMode === 'typingTest') {
                startTypingTest(); // Ta gra buduje swój własny interfejs od razu
                return;
            }
            if (gameMode === 'memoryGame') {
                startMemoryGame(); // Ta gra też startuje od razu
                return;
            }

            // Stwórz ekran startowy dla wybranej gry
            const gameStartScreen = `
                <div class="game-start-screen" id="start-screen-${gameMode}">
                    <h2 class="game-title">${title}</h2>
                    <p class="game-description">${description}</p>
                    <button class="btn btn-primary" id="start-game-btn" data-start-game="${gameMode}">
                        ${buttonText}
                    </button>
                </div>
            `;
            D.gameContainer.innerHTML = gameStartScreen;
            
            // Znajdź nowo utworzony przycisk startu i dodaj listener
            const startGameBtn = document.getElementById('start-game-btn');
            startGameBtn.addEventListener('click', handleGameStartClick);
        }

        /**
         * Pokazuje ekran treści statycznej (Blog/FAQ).
         * @param {string} sectionName - Nazwa sekcji ('blog' lub 'faq').
         */
        function showStaticScreen(sectionName) {
            const D = AppState.DOM;
            
            // Zatrzymaj aktywną grę
            stopCurrentGame();
            
            // Ukryj ekran powitalny i kontener gry
            D.welcomeScreen.classList.remove('active');
            D.gameContainer.hidden = true;
            
            // Pokaż kontener statyczny
            D.staticContentContainer.hidden = false;
            
            // Załaduj odpowiednią treść (placeholder)
            if (sectionName === 'blog') {
                D.staticContentContainer.innerHTML = `<h2>Blog / Poradniki</h2><p>Treść bloga pojawi się tutaj...</p>`;
            } else if (sectionName === 'faq') {
                D.staticContentContainer.innerHTML = `<h2>FAQ - Najczęściej Zadawane Pytania</h2><p>Treść FAQ pojawi się tutaj...</p>`;
            }
        }

        /**
         * Inicjalizuje obsługę wszystkich okien modalnych.
         */
        function initializeModals() {
            const D = AppState.DOM;
            
            // Zamykanie Modala Statystyk
            D.statsModalCloseBtns.forEach(btn => {
                btn.addEventListener('click', () => closeModal('stats-modal'));
            });
            // Zamykanie Modala Reklamy
            D.adNotificationModalCloseBtns.forEach(btn => {
                btn.addEventListener('click', () => closeModal('ad-notification-modal'));
            });
            
            // Zamykanie modala klawiszem Escape (dla dostępności) [16]
            window.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    if (D.statsModal.open) {
                        closeModal('stats-modal');
                    }
                    if (D.adNotificationModal.open) {
                        closeModal('ad-notification-modal');
                    }
                }
            });
            
            // Zamykanie modala po kliknięciu na tło (backdrop) 
            D.statsModal.addEventListener('click', (e) => {
                if (e.target.id === 'stats-modal') closeModal('stats-modal');
            });
            D.adNotificationModal.addEventListener('click', (e) => {
                if (e.target.id === 'ad-notification-modal') closeModal('ad-notification-modal');
            });
        }

        /**
         * Otwiera określone okno modalne (dialog).
         * Używa .showModal() dla natywnej obsługi modala.
         * Zarządza fokusem dla dostępności.
         * @param {string} modalId - ID modala do otwarcia.
         */
        function openModal(modalId) {
            const modal = document.getElementById(modalId);
            if (!modal) return;
            
            modal.showModal(); // [14]
            
            // Przeniesienie fokusu na modal (lub pierwszy element w nim) dla WAI-ARIA [16]
            const firstFocusableElement = modal.querySelector('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
            if (firstFocusableElement) {
                firstFocusableElement.focus();
            }
        }

        /**
         * Zamyka określone okno modalne.
         * Używa .close().
         * @param {string} modalId - ID modala do zamknięcia.
         */
        function closeModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.close();
            }
            // Przywracanie fokusu do elementu, który otworzył modal,
            // powinno być zaimplementowane, jeśli przechowujemy referencję do 'triggera' [16]
        }

        /*
        =======================================================================
         4. Moduł 4: Zarządzanie Danymi (LocalStorage, Wyniki)
            - Implementacja zapisu i odczytu jako pojedynczy obiekt JSON.
            - Zarządzanie najlepszymi wynikami.[32, 33]
        =======================================================================
        */

        // Klucz główny dla localStorage
        const LOCAL_STORAGE_KEY_SETTINGS = 'reflexCoreSettings';
        const LOCAL_STORAGE_KEY_SCORES = 'reflexCoreHighScores';

        /**
         * Zapisuje pojedyncze ustawienie lub całą grupę w localStorage.
         * @param {string} key - Klucz główny (np. 'theme' lub 'gameSettings').
         * @param {*} value - Wartość do zapisania.
         */
        function saveSetting(key, value) {
            AppState.settings[key] = value;
            // Zapisujemy cały obiekt ustawień jako JSON 
            localStorage.setItem(LOCAL_STORAGE_KEY_SETTINGS, JSON.stringify(AppState.settings));
        }

        /**
         * Wczytuje ustawienia z localStorage podczas inicjalizacji.
         */
        function loadSettings() {
            // Używamy "try...catch" na wypadek, gdyby localStorage było wyłączone lub dane były uszkodzone
            try {
                const savedSettings = localStorage.getItem(LOCAL_STORAGE_KEY_SETTINGS);
                
                if (savedSettings) {
                    const parsedSettings = JSON.parse(savedSettings);
                    // Łączymy zapisane ustawienia z domyślnymi, aby uniknąć błędów
                    // Używamy głębokiego łączenia dla gameSettings
                    AppState.settings = {
                        ...AppState.settings,
                        ...parsedSettings,
                        gameSettings: {
                            ...AppState.settings.gameSettings,
                            ...(parsedSettings.gameSettings || {})
                        }
                    };
                }
            } catch (error) {
                console.error("Nie udało się załadować ustawień z localStorage:", error);
            }
            
            // Zastosuj wczytane (lub domyślne) ustawienia
            applyTheme(AppState.settings.theme);
            applyLanguage(AppState.settings.language);
            applySavedGameSettings();
        }

        /**
         * Zapisuje najlepsze wyniki w localStorage.
         * @param {string} gameMode - ID trybu gry.
         * @param {object} scoreData - Obiekt z wynikiem (np. { score: 100, reaction: 150 }).
         */
        function saveHighScore(gameMode, scoreData) {
            // Zapisujemy cały obiekt wyników [32, 34]
            AppState.highScores[gameMode] = scoreData;
            try {
                localStorage.setItem(LOCAL_STORAGE_KEY_SCORES, JSON.stringify(AppState.highScores));
            } catch (error) {
                console.error("Nie udało się zapisać wyników w localStorage:", error);
            }
            
            // Odśwież wyświetlanie wyników na ekranie głównym
            updateHighScoresDisplay();
        }

        /**
         * Wczytuje najlepsze wyniki z localStorage.
         */
        function loadHighScores() {
            try {
                const savedScores = localStorage.getItem(LOCAL_STORAGE_KEY_SCORES);
                if (savedScores) {
                    AppState.highScores = JSON.parse(savedScores);
                }
            } catch (error) {
                console.error("Nie udało się załadować wyników z localStorage:", error);
            }
            
            // Odśwież wyświetlanie
            updateHighScoresDisplay();
        }

        /**
         * Aktualizuje sekcję "Najlepsze Wyniki" na ekranie powitalnym.
         */
        function updateHighScoresDisplay() {
            const D = AppState.DOM;
            if (!D.highScoresDisplay) return;
            
            const scores = AppState.highScores;
            let html = '';
            
            if (Object.keys(scores).length === 0) {
                html = '<p>Brak zapisanych wyników. Zagraj w grę, aby ustanowić rekord!</p>';
            } else {
                html = '<ul>';
                if (scores.aimTrainer) {
                    html += `<li><strong>Trener Celności:</strong> ${scores.aimTrainer.score} pkt (Avg: ${scores.aimTrainer.reaction}ms)</li>`;
                }
                if (scores.tracking) {
                    html += `<li><strong>Śledzenie:</strong> ${scores.tracking.score.toFixed(2)}% celności</li>`;
                }
                if (scores.typingTest) {
                    html += `<li><strong>Test Pisania:</strong> ${scores.typingTest.wpm} WPM (Celność: ${scores.typingTest.accuracy}%)</li>`;
                }
                if (scores.memoryGame) {
                    html += `<li><strong>Gra Pamięciowa:</strong> ${scores.memoryGame.moves} ruchów</li>`;
                }
                if (scores.whacAMole) {
                    html += `<li><strong>Whac-a-Mole:</strong> ${scores.whacAMole.score} pkt</li>`;
                }
                html += '</ul>';
            }
            
            D.highScoresDisplay.innerHTML = html;
        }

        /**
         * Obsługuje resetowanie najlepszych wyników.
         */
        function handleResetHighScores() {
            if (confirm('Czy na pewno chcesz zresetować wszystkie swoje najlepsze wyniki? Tej operacji nie można cofnąć.')) {
                AppState.highScores = {};
                try {
                    localStorage.removeItem(LOCAL_STORAGE_KEY_SCORES);
                } catch (error) {
                    console.error("Błąd podczas resetowania wyników:", error);
                }
                updateHighScoresDisplay();
                console.log("Najlepsze wyniki zostały zresetowane.");
            }
        }


        /*
        =======================================================================
         5. Moduł 5: Tryb Gry - Trener Celności (Aim Trainer)
            - Pełna logika gry: klikanie celów.
            - Obliczanie średniego czasu reakcji.[35, 36]
            - Obliczanie CPS (Clicks Per Second).[37, 38]
        =======================================================================
        */

        // Ustawienia specyficzne dla gry Aim Trainer
        const AimTrainerSettings = {
            GAME_DURATION: 30000 // 30 sekund
        };

        /**
         * Rozpoczyna grę w trybie Aim Trainer.
         */
        function startAimTrainer() {
            const D = AppState.DOM;
            const C = AppState.currentGame;
            
            C.gameMode = 'aimTrainer';
            
            // Przygotowanie kontenera gry
            D.gameContainer.innerHTML = '<div class="game-area" id="aim-trainer-area"></div>';
            D.gameArea = document.getElementById('aim-trainer-area');
            
            // Resetowanie statystyk
            C.isActive = true;
            C.hits = 0;
            C.misses = 0;
            C.reactionTimes = [];
            C.lastReactionTime = Date.now();
            resetLiveStats();
            
            // Obsługa kliknięć (trafienia/pudła)
            D.gameArea.addEventListener('mousedown', handleAimTrainerClick);
            
            // Start pomiaru CPS [39]
            startCPSMeasure();
            
            // Start timera gry
            C.startTime = Date.now();
            C.timerInterval = setInterval(updateGameTimer, 100);
            
            // Ustawienie timera kończącego grę
            setTimeout(stopAimTrainer, AimTrainerSettings.GAME_DURATION);
            
            // Stworzenie pierwszego celu
            spawnTarget();
        }

        /**
         * Zatrzymuje grę w trybie Aim Trainer.
         */
        function stopAimTrainer() {
            const C = AppState.currentGame;
            if (!C.isActive || C.gameMode !== 'aimTrainer') return;
            
            C.isActive = false;
            C.endTime = Date.now();
            clearInterval(C.timerInterval);
            stopCPSMeasure();
            
            // Usunięcie listenera, aby uniknąć kliknięć po zakończeniu
            if (AppState.DOM.gameArea) {
                AppState.DOM.gameArea.removeEventListener('mousedown', handleAimTrainerClick);
            }
            
            // Usunięcie ostatniego celu
            const target = AppState.DOM.gameArea.querySelector('.target');
            if (target) {
                target.remove();
            }
            
            // Obliczenie finałowych statystyk
            showFinalStats('aimTrainer');
        }

        /**
         * Tworzy i wyświetla nowy cel w losowym miejscu.
         */
        function spawnTarget() {
            const C = AppState.currentGame;
            if (!C.isActive) return;
            
            const D = AppState.DOM;
            const gameArea = D.gameArea;
            if (!gameArea) return; // Zabezpieczenie, jeśli gra skończyła się w międzyczasie

            // Usunięcie poprzedniego celu, jeśli istnieje
            const oldTarget = gameArea.querySelector('.target');
            if (oldTarget) {
                oldTarget.remove();
            }
            
            const target = document.createElement('div');
            target.className = 'target';
            
            // Pobranie dynamicznego rozmiaru ze zmiennej CSS (ustawianej w panelu)
            const targetSize = parseInt(D.root.style.getPropertyValue('--target-size') || AppState.settings.gameSettings['--target-size']);
            
            // Obliczenie losowej pozycji
            const maxWidth = gameArea.clientWidth - targetSize;
            const maxHeight = gameArea.clientHeight - targetSize;
            
            const x = Math.floor(Math.random() * maxWidth);
            const y = Math.floor(Math.random() * maxHeight);
            
            target.style.left = `${x}px`;
            target.style.top = `${y}px`;
            
            // Listener dla trafienia
            target.addEventListener('mousedown', handleTargetHit);
            
            gameArea.appendChild(target);
            
            // Zapisz czas pojawienia się celu do obliczenia czasu reakcji
            C.lastReactionTime = Date.now();
        }

        /**
         * Obsługuje kliknięcie w obszarze gry (trafienie lub pudło).
         * @param {Event} e - Zdarzenie 'mousedown'.
         */
        function handleAimTrainerClick(e) {
            // Sprawdź, czy kliknięto bezpośrednio na obszar gry (pudło)
            if (e.target.id === 'aim-trainer-area') {
                handleTargetMiss();
            }
        }

        /**
         * Obsługuje trafienie w cel.
         * @param {Event} e - Zdarzenie 'mousedown' na celu.
         */
        function handleTargetHit(e) {
            const C = AppState.currentGame;
            if (!C.isActive) return;
            
            // Zapobiegaj propagacji zdarzenia do gameArea (aby nie zliczyło pudła)
            e.stopPropagation();
            
            // Oblicz czas reakcji [35]
            const reactionTime = Date.now() - C.lastReactionTime;
            C.reactionTimes.push(reactionTime);
            
            C.hits++;
            updateLiveStats();
            
            // Natychmiastowe stworzenie nowego celu
            spawnTarget();
        }

        /**
         * Obsługuje pudło (kliknięcie obok celu).
         */
        function handleTargetMiss() {
            const C = AppState.currentGame;
            if (!C.isActive) return;
            
            C.misses++;
            updateLiveStats();
            
            // Opcjonalnie: można dodać efekt wizualny/dźwiękowy dla pudła
        }

        /**
         * Oblicza średni czas reakcji z tablicy.[35, 36]
         * @returns {number} - Średni czas reakcji w ms.
         */
        function calculateAverageReactionTime() {
            const C = AppState.currentGame;
            if (C.reactionTimes.length === 0) return 0;
            
            const sum = C.reactionTimes.reduce((a, b) => a + b, 0);
            return Math.round(sum / C.reactionTimes.length);
        }

        /**
         * Rozpoczyna pomiar CPS (Clicks Per Second).
         */
        function startCPSMeasure() {
            const C = AppState.currentGame;
            const CPS = C.cpsCounter;
            
            if (CPS.isMeasuring) return;
            
            CPS.isMeasuring = true;
            CPS.clicks = 0;
            
            // Listener do zliczania wszystkich kliknięć
            if(AppState.DOM.gameArea) {
                AppState.DOM.gameArea.addEventListener('mousedown', countClickForCPS);
            }
            
            // Timer do resetowania licznika CPS co sekundę (dla statystyk na żywo)
            // To jest jedna z metod pomiaru CPS [39]
            CPS.timer = setInterval(() => {
                // Aktualizacja CPS na żywo (jeśli mamy taki stat w sidebarze)
                // console.log(`CPS: ${CPS.clicks}`);
                CPS.clicks = 0; // Resetuj co sekundę
            }, 1000);
        }

        /**
         * Zlicza kliknięcie dla pomiaru CPS.
         */
        function countClickForCPS() {
            if (AppState.currentGame.cpsCounter.isMeasuring) {
                AppState.currentGame.cpsCounter.clicks++;
            }
        }

        /**
         * Zatrzymuje pomiar CPS.
         */
        function stopCPSMeasure() {
            const C = AppState.currentGame;
            const CPS = C.cpsCounter;
            
            if (!CPS.isMeasuring) return;
            
            CPS.isMeasuring = false;
            clearInterval(CPS.timer);
            if (AppState.DOM.gameArea) {
                AppState.DOM.gameArea.removeEventListener('mousedown', countClickForCPS);
            }
        }

        /**
         * Oblicza finałowy, średni CPS dla całej sesji.[38]
         * @returns {number} - Średni CPS.
         */
        function calculateFinalCPS() {
            const C = AppState.currentGame;
            const totalClicks = C.hits + C.misses;
            const durationInSeconds = (C.endTime - C.startTime) / 1000;
            
            if (durationInSeconds === 0) return 0;
            
            return (totalClicks / durationInSeconds).toFixed(2);
        }


        /*
        =======================================================================
         6. Moduł 6: Tryb Gry - Śledzenie (Tracking)
            - Implementacja na podstawie tutoriali.[31, 24]
            - Logika ruchomego celu i obliczanie celności na podstawie czasu.
        =======================================================================
        */

        // Ustawienia specyficzne dla gry Tracking
        const TrackingSettings = {
            GAME_DURATION: 30000, // 30 sekund
            TARGET_SPEED: 3,      // piksele na klatkę
            UPDATE_RATE: 1000 / 60 // 60 FPS
        };

        // Stan specyficzny dla gry Tracking
        const TrackingState = {
            targetEl: null,
            targetPos: { x: 50, y: 50 },
            targetVel: { x: TrackingSettings.TARGET_SPEED, y: TrackingSettings.TARGET_SPEED },
            gameLoop: null,
            isMouseOverTarget: false,
            timeOnTarget: 0,
            totalTime: 0
        };

        /**
         * Rozpoczyna grę w trybie Tracking.
         */
        function startTrackingGame() {
            const D = AppState.DOM;
            const C = AppState.currentGame;
            
            C.gameMode = 'tracking';
            
            // Przygotowanie kontenera gry
            D.gameContainer.innerHTML = '<div class="game-area" id="tracking-area"></div>';
            D.gameArea = document.getElementById('tracking-area');
            
            // Stworzenie celu
            const target = document.createElement('div');
            target.className = 'target';
            D.gameArea.appendChild(target);
            TrackingState.targetEl = target;
            
            // Resetowanie statystyk
            C.isActive = true;
            C.hits = 0; // W tej grze "hits" to czas na celu
            C.misses = 0; // "misses" to czas poza celem
            TrackingState.timeOnTarget = 0;
            TrackingState.totalTime = 0;
            TrackingState.isMouseOverTarget = false;
            
            // Resetowanie pozycji celu
            TrackingState.targetPos = { x: 50, y: 50 };
            TrackingState.targetVel = { x: TrackingSettings.TARGET_SPEED, y: TrackingSettings.TARGET_SPEED };
            
            resetLiveStats();
            
            // Listenery do śledzenia myszy na celu
            TrackingState.targetEl.addEventListener('mouseenter', () => {
                TrackingState.isMouseOverTarget = true;
            });
            TrackingState.targetEl.addEventListener('mouseleave', () => {
                TrackingState.isMouseOverTarget = false;
            });
            
            // Start timera gry
            C.startTime = Date.now();
            C.timerInterval = setInterval(updateGameTimer, 100);
            
            // Start głównej pętli gry (animacja celu)
            TrackingState.gameLoop = setInterval(updateTrackingGame, TrackingSettings.UPDATE_RATE);
            
            // Ustawienie timera kończącego grę
            setTimeout(stopTrackingGame, TrackingSettings.GAME_DURATION);
        }

        /**
         * Zatrzymuje grę w trybie Tracking.
         */
        function stopTrackingGame() {
            const C = AppState.currentGame;
            if (!C.isActive || C.gameMode !== 'tracking') return;
            
            C.isActive = false;
            C.endTime = Date.now();
            clearInterval(C.timerInterval);
            clearInterval(TrackingState.gameLoop);
            
            // Usunięcie celu
            if (TrackingState.targetEl) {
                TrackingState.targetEl.remove();
                TrackingState.targetEl = null;
            }
            
            // Obliczenie finałowych statystyk
            showFinalStats('tracking');
        }

        /**
         * Główna pętla gry Tracking (aktualizowana 60 razy na sekundę).
         */
        function updateTrackingGame() {
            const C = AppState.currentGame;
            if (!C.isActive) return;
            
            const D = AppState.DOM;
            const S = TrackingState;
            const gameArea = D.gameArea;
            const target = S.targetEl;
            
            if (!gameArea || !target) return;
            
            const targetSize = parseInt(D.root.style.getPropertyValue('--target-size') || AppState.settings.gameSettings['--target-size']);
            const areaWidth = gameArea.clientWidth;
            const areaHeight = gameArea.clientHeight;

            // Aktualizacja pozycji celu
            S.targetPos.x += S.targetVel.x;
            S.targetPos.y += S.targetVel.y;

            // Odbijanie od ścianek
            if (S.targetPos.x <= 0 || S.targetPos.x >= areaWidth - targetSize) {
                S.targetVel.x *= -1; // Zmień kierunek X
            }
            if (S.targetPos.y <= 0 || S.targetPos.y >= areaHeight - targetSize) {
                S.targetVel.y *= -1; // Zmień kierunek Y
            }
            
            // Zapewnienie, że cel pozostaje w granicach
            S.targetPos.x = Math.max(0, Math.min(S.targetPos.x, areaWidth - targetSize));
            S.targetPos.y = Math.max(0, Math.min(S.targetPos.y, areaHeight - targetSize));

            // Zastosowanie nowej pozycji
            target.style.left = `${S.targetPos.x}px`;
            target.style.top = `${S.targetPos.y}px`;
            
            // Zliczanie czasu na celu
            S.totalTime += TrackingSettings.UPDATE_RATE;
            if (S.isMouseOverTarget) {
                S.timeOnTarget += TrackingSettings.UPDATE_RATE;
                C.hits = S.timeOnTarget; // Używamy 'hits' do przechowywania czasu na celu
            } else {
                C.misses = S.totalTime - S.timeOnTarget; // 'misses' to czas poza celem
            }
            
            // Aktualizacja statystyk na żywo
            updateLiveStats();
        }


        /*
        =======================================================================
         7. Moduł 7: Tryb Gry - Test Szybkiego Pisania (Typing Test)
            - Implementacja na podstawie tutoriali.[25, 26, 40]
            - Ładowanie tekstu, obsługa klawiszy, obliczanie WPM i celności.
        =======================================================================
        */

        // Ustawienia specyficzne dla gry Typing Test
        const TypingTestSettings = {
            GAME_DURATION: 60000, // 60 sekund
            // Przykładowe teksty do pisania (można je ładować z API)
            TEXT_SAMPLES: [
                "Szybki brązowy lis przeskakuje nad leniwym psem. To zdanie zawiera wszystkie litery alfabetu i jest często używane do testowania czcionek oraz klawiatur.",
                "Programowanie to sztuka i nauka tworzenia instrukcji dla komputera. Wymaga logiki, kreatywności i cierpliwości. Każdy może się tego nauczyć.",
                "ReflexCore pomaga poprawić czas reakcji. Regularny trening celności jest kluczowy dla graczy komputerowych. Ćwicz codziennie, aby zobaczyć najlepsze rezultaty.",
                "Morze Bałtyckie jest stosunkowo młodym i płytkim morzem śródlądowym. Jego zasolenie jest znacznie niższe niż w przypadku większości innych mórz."
            ]
        };

        // Stan specyficzny dla gry Typing Test
        const TypingState = {
            textToType: "",
            currentIndex: 0,
            errors: 0,
            totalTyped: 0,
            startTime: 0,
            inputElement: null,
            textDisplayElement: null
        };

        /**
         * Rozpoczyna grę w trybie Typing Test.
         */
        function startTypingTest() {
            const D = AppState.DOM;
            const C = AppState.currentGame;
            
            C.gameMode = 'typingTest';
            
            // Wygeneruj interfejs gry
            D.gameContainer.innerHTML = `
                <div class="typing-test-container">
                    <div class="typing-stats">
                        <div class="typing-stat-item">
                            <div class="typing-stat-label">Czas</div>
                            <div class="typing-stat-value" id="typing-timer">60</div>
                        </div>
                        <div class="typing-stat-item">
                            <div class="typing-stat-label">WPM</div>
                            <div class="typing-stat-value" id="typing-wpm">0</div>
                        </div>
                        <div class="typing-stat-item">
                            <div class="typing-stat-label">Błędy</div>
                            <div class="typing-stat-value" id="typing-errors">0</div>
                        </div>
                        <div class="typing-stat-item">
                            <div class="typing-stat-label">Celność</div>
                            <div class="typing-stat-value" id="typing-accuracy">100%</div>
                        </div>
                    </div>
                    <div class="typing-text-display" id="typing-text-display"></div>
                    <input type="text" class="typing-input-area" id="typing-input-area" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" autofocus>
                    <button class="btn btn-primary typing-restart-btn" id="typing-restart-btn" hidden>Spróbuj Ponownie</button>
                </div>
            `;
            
            // Zapisz referencje do nowych elementów DOM
            TypingState.inputElement = document.getElementById('typing-input-area');
            TypingState.textDisplayElement = document.getElementById('typing-text-display');
            const timerDisplay = document.getElementById('typing-timer');
            const restartBtn = document.getElementById('typing-restart-btn');
            
            // Zresetuj statystyki
            C.isActive = true;
            C.hits = 0; // Użyjemy hits dla WPM
            C.misses = 0; // Użyjemy misses dla błędów
            TypingState.currentIndex = 0;
            TypingState.errors = 0;
            TypingState.totalTyped = 0;
            TypingState.startTime = 0; // Zostanie ustawione przy pierwszym znaku
            
            // Załaduj i wyświetl tekst
            loadTypingText();
            
            // Dodaj listenery
            TypingState.inputElement.addEventListener('input', handleTypingInput);
            TypingState.inputElement.addEventListener('keydown', handleTypingBackspace); // Do obsługi backspace
            restartBtn.addEventListener('click', () => showGameScreen('typingTest')); // Restart
            
            // Ustaw fokus na polu do pisania
            TypingState.inputElement.focus();
            
            // Start timera (ale inaczej niż w Aim Trainer)
            let timeLeft = TypingTestSettings.GAME_DURATION / 1000;
            timerDisplay.textContent = timeLeft;
            
            C.timerInterval = setInterval(() => {
                // Timer rusza dopiero po rozpoczęciu pisania
                if (C.isActive && TypingState.startTime > 0) {
                    timeLeft--;
                    timerDisplay.textContent = timeLeft;
                    
                    // Aktualizuj WPM na żywo
                    updateTypingStats(false);
                    
                    if (timeLeft <= 0) {
                        stopTypingTest();
                    }
                }
            }, 1000);
        }

        /**
         * Zatrzymuje grę w trybie Typing Test.
         */
        function stopTypingTest() {
            const C = AppState.currentGame;
            if (!C.isActive || C.gameMode !== 'typingTest') return;
            
            C.isActive = false;
            C.endTime = Date.now();
            clearInterval(C.timerInterval);
            
            // Zablokuj pole do pisania
            TypingState.inputElement.disabled = true;
            
            // Pokaż przycisk restartu
            document.getElementById('typing-restart-btn').hidden = false;
            
            // Oblicz i pokaż finałowe statystyki
            updateTypingStats(true); // Końcowe obliczenie
            showFinalStats('typingTest');
        }

        /**
         * Ładuje nowy tekst do przepisania i renderuje go w kontenerze.
         */
        function loadTypingText() {
            const S = TypingTestSettings;
            const T = TypingState;
            
            // Wybierz losowy tekst
            T.textToType = S.TEXT_SAMPLES[Math.floor(Math.random() * S.TEXT_SAMPLES.length)];
            
            // Przekształć tekst na tablicę spanów (liter)
            const characters = T.textToType.split('').map(char => {
                return `<span class="char">${char}</span>`;
            }).join('');
            
            T.textDisplayElement.innerHTML = characters;
            
            // Podświetl pierwszy znak
            T.textDisplayElement.querySelector('.char').classList.add('current');
        }

        /**
         * Obsługuje wprowadzanie tekstu przez użytkownika.[26]
         * @param {Event} e - Zdarzenie 'input'.
         */
        function handleTypingInput(e) {
            const C = AppState.currentGame;
            const T = TypingState;
            
            if (!C.isActive) return;
            
            // Uruchom timer przy pierwszym znaku
            if (T.startTime === 0) {
                T.startTime = Date.now();
            }
            
            const allChars = T.textDisplayElement.querySelectorAll('.char');
            const typedChar = e.data; // Ostatni wpisany znak

            // Ignoruj, jeśli to był backspace (obsłużony w handleTypingBackspace)
            if (typedChar === null) return; 

            // Ignoruj, jeśli doszliśmy do końca
            if (T.currentIndex >= T.textToType.length) return;

            const charToType = T.textToType[T.currentIndex];
            const currentDisplayChar = allChars[T.currentIndex];
            
            T.totalTyped++;
            
            if (typedChar === charToType) {
                // Poprawny znak
                currentDisplayChar.classList.add('correct');
                C.hits++; // Użyjemy 'hits' do liczenia poprawnych znaków (do WPM)
            } else {
                // Niepoprawny znak
                currentDisplayChar.classList.add('incorrect');
                T.errors++;
                C.misses = T.errors; // 'misses' dla błędów
            }
            
            currentDisplayChar.classList.remove('current');
            T.currentIndex++;
            
            // Sprawdź, czy gra się nie skończyła (przepisany cały tekst)
            if (T.currentIndex === T.textToType.length) {
                stopTypingTest();
                return;
            }
            
            // Podświetl następny znak
            allChars[T.currentIndex].classList.add('current');
            
            // Aktualizuj statystyki na żywo (ale nie WPM, to robi timer)
            updateTypingStats(false);
        }

        /**
         * Obsługuje backspace w teście pisania
         */
        function handleTypingBackspace(e) {
            const T = TypingState;
            if (e.key !== 'Backspace' || T.currentIndex === 0 || !AppState.currentGame.isActive) {
                return;
            }

            // Zapobiegaj domyślnej akcji (usuwaniu z inputa)
            e.preventDefault();

            const allChars = T.textDisplayElement.querySelectorAll('.char');
            
            // Usuń "current" z obecnego znaku
            allChars[T.currentIndex].classList.remove('current');

            // Przesuń indeks
            T.currentIndex--;

            // Znak, do którego wracamy
            const charToCorrect = allChars[T.currentIndex];
            
            // Sprawdź, czy był błędny
            if (charToCorrect.classList.contains('incorrect')) {
                T.errors--;
                AppState.currentGame.misses = T.errors;
            }
            if (charToCorrect.classList.contains('correct')) {
                AppState.currentGame.hits--;
            }

            // Wyczyść jego stan i ustaw jako "current"
            charToCorrect.classList.remove('correct', 'incorrect');
            charToCorrect.classList.add('current');

            // Zaktualizuj pole input
            T.inputElement.value = T.inputElement.value.slice(0, -1);
            
            T.totalTyped--; // Zmniejszamy też ogólną liczbę wpisanych
            updateTypingStats(false);
        }


        /**
         * Aktualizuje statystyki WPM, Błędy, Celność na żywo lub na koniec gry.
         * @param {boolean} isFinal - Czy to końcowe obliczenie?
         */
        function updateTypingStats(isFinal) {
            const C = AppState.currentGame;
            const T = TypingState;
            
            const errorsDisplay = document.getElementById('typing-errors');
            const accuracyDisplay = document.getElementById('typing-accuracy');
            const wpmDisplay = document.getElementById('typing-wpm');

            if (!errorsDisplay) return; // Zabezpieczenie na wypadek przełączenia gry

            // Aktualizuj błędy
            errorsDisplay.textContent = T.errors;
            
            // Oblicz celność
            let accuracy = 100;
            if (T.totalTyped > 0) {
                accuracy = Math.round(((T.totalTyped - T.errors) / T.totalTyped) * 100);
            }
            accuracyDisplay.textContent = `${accuracy}%`;
            C.accuracy = accuracy; // Zapisz do stanu globalnego
            
            // Oblicz WPM (Words Per Minute) [26]
            let timeElapsedInMinutes = (Date.now() - T.startTime) / 60000;
            if (isFinal) {
                // Użyj dokładnego czasu, jeśli gra się skończyła
                const duration = (C.endTime > 0) ? (C.endTime - T.startTime) : TypingTestSettings.GAME_DURATION;
                timeElapsedInMinutes = duration / 60000;
            }
            
            if (timeElapsedInMinutes === 0 || T.startTime === 0) {
                wpmDisplay.textContent = 0;
                return;
            }
            
            // Standardowa formuła: (liczba poprawnych słów) / minuty
            // Słowo = średnio 5 znaków (wliczając spacje)
            // Używamy C.hits (poprawne znaki) / 5
            const netWPM = Math.round( (C.hits / 5) / timeElapsedInMinutes );
            
            const finalWPM = Math.max(0, netWPM); // Nie pokazuj ujemnego WPM
            
            wpmDisplay.textContent = finalWPM;
            
            // Zapisz do statystyk końcowych
            C.hits = finalWPM; // 'hits' jako WPM
            C.misses = T.errors;
        }


        /*
        =======================================================================
         8. Moduł 8: Tryb Gry - Gra Pamięciowa (Memory Game)
            - Implementacja na podstawie tutoriali.[27, 20, 41, 42]
            - Logika tasowania, odwracania kart i sprawdzania dopasowania.
        =======================================================================
        */

        // Ustawienia specyficzne dla gry Memory
        const MemoryGameSettings = {
            CARD_EMOJIS: ['🐶', '🐱', '🐭', '🐹', '🐰', '🦊', '🐻', '🐼'], // 8 par = 16 kart
            FLIP_DELAY: 1000 // 1 sekunda na zapamiętanie [41]
        };

        // Stan specyficzny dla gry Memory
        const MemoryState = {
            cards: [], // Tablica elementów DOM kart
            flippedCards: [], // Maksymalnie 2 karty
            matchedPairs: 0,
            totalMoves: 0,
            lockBoard: false // Blokada planszy podczas animacji 
        };

        /**
         * Rozpoczyna grę w trybie Memory.
         */
        function startMemoryGame() {
            const D = AppState.DOM;
            const C = AppState.currentGame;
            
            C.gameMode = 'memoryGame';
            
            // Przygotowanie kontenera gry
            D.gameContainer.innerHTML = `
                <div class="game-start-screen" id="start-screen-memoryGame">
                     <h2 class="game-title">Gra Pamięciowa</h2>
                     <p class="game-description" style="margin-bottom: 1rem;">
                        Ruchy: <span id="memory-moves" style="font-size: 1.2rem; font-weight: bold; color: var(--accent-color);">0</span>
                     </p>
                     <div class="memory-game-grid" id="memory-grid"></div>
                     <button class="btn btn-primary" id="memory-restart-btn" style="margin-top: 1.5rem;">Restart</button>
                </div>
            `;
            
            // Zapisz referencje
            const grid = document.getElementById('memory-grid');
            const movesDisplay = document.getElementById('memory-moves');
            const restartBtn = document.getElementById('memory-restart-btn');
            
            // Reset stanu
            C.isActive = true;
            MemoryState.flippedCards = [];
            MemoryState.matchedPairs = 0;
            MemoryState.totalMoves = 0;
            MemoryState.lockBoard = false;
            C.hits = 0; // 'hits' to będą ruchy
            movesDisplay.textContent = '0';
            
            // Wygeneruj i potasuj karty
            const cardSet = [...MemoryGameSettings.CARD_EMOJIS, ...MemoryGameSettings.CARD_EMOJIS];
            shuffleArray(cardSet); // [20]
            
            // Stwórz karty w DOM
            grid.innerHTML = ''; // Wyczyść na wypadek restartu
            MemoryState.cards = cardSet.map(emoji => createMemoryCard(emoji));
            MemoryState.cards.forEach(card => grid.appendChild(card));
            
            // Dodaj listener do przycisku restartu
            restartBtn.addEventListener('click', () => showGameScreen('memoryGame'));
        }

        /**
         * Tworzy pojedynczą kartę do gry Memory.
         * @param {string} emoji - Emoji, które będzie na karcie.
         * @returns {HTMLElement} - Element DOM karty.
         */
        function createMemoryCard(emoji) {
            const card = document.createElement('div');
            card.className = 'memory-card';
            card.dataset.emoji = emoji; // Zapisujemy emoji w atrybucie data
            
            card.innerHTML = `
                <div class="front-face">${emoji}</div>
                <div class="back-face">?</div>
            `;
            
            // Dodaj listener do odwracania
            card.addEventListener('click', () => handleMemoryCardFlip(card));
            return card;
        }

        /**
         * Obsługuje kliknięcie (odwrócenie) karty.
         * @param {HTMLElement} card - Kliknięta karta.
         */
        function handleMemoryCardFlip(card) {
            const M = MemoryState;
            const C = AppState.currentGame;
            
            // Nie rób nic, jeśli plansza jest zablokowana, karta jest już odwrócona, lub już mamy 2 karty
            if (M.lockBoard || card.classList.contains('flip') || M.flippedCards.length === 2 || card === M.flippedCards[0]) {
                return;
            }
            
            card.classList.add('flip');
            M.flippedCards.push(card);
            
            // Jeśli to pierwsza karta, po prostu czekaj
            if (M.flippedCards.length === 1) {
                return;
            }
            
            // Jeśli to druga karta, zlicz ruch i sprawdź dopasowanie
            M.totalMoves++;
            C.hits = M.totalMoves;
            document.getElementById('memory-moves').textContent = M.totalMoves;
            
            // Zablokuj planszę na czas sprawdzania 
            M.lockBoard = true;
            
            checkForMemoryMatch();
        }

        /**
         * Sprawdza, czy dwie odwrócone karty pasują do siebie.
         */
        function checkForMemoryMatch() {
            const M = MemoryState;
            const [cardOne, cardTwo] = M.flippedCards;
            
            const isMatch = cardOne.dataset.emoji === cardTwo.dataset.emoji;
            
            if (isMatch) {
                // Trafienie
                disableMatchedCards();
            } else {
                // Pudło
                unflipMismatchedCards();
            }
        }

        /**
         * Blokuje dopasowane karty (pozostają odwrócone).
         */
        function disableMatchedCards() {
            const M = MemoryState;
            M.flippedCards[0].removeEventListener('click', handleMemoryCardFlip);
            M.flippedCards[1].removeEventListener('click', handleMemoryCardFlip);
            
            M.matchedPairs++;
            resetMemoryBoard();
            
            // Sprawdź warunek zwycięstwa
            if (M.matchedPairs === MemoryGameSettings.CARD_EMOJIS.length) {
                setTimeout(stopMemoryGame, 500); // Małe opóźnienie na animację
            }
        }

        /**
         * Odwraca z powrotem niedopasowane karty po krótkim opóźnieniu.[41]
         */
        function unflipMismatchedCards() {
            const M = MemoryState;
            setTimeout(() => {
                M.flippedCards[0].classList.remove('flip');
                M.flippedCards[1].classList.remove('flip');
                resetMemoryBoard();
            }, MemoryGameSettings.FLIP_DELAY);
        }

        /**
         * Resetuje stan planszy po ruchu (zeruje tablicę odwróconych kart).
         */
        function resetMemoryBoard() {
            MemoryState.flippedCards = [];
            MemoryState.lockBoard = false;
        }

        /**
         * Kończy grę w trybie Memory.
         */
        function stopMemoryGame() {
            const C = AppState.currentGame;
            if (!C.isActive || C.gameMode !== 'memoryGame') return;
            
            C.isActive = false;
            C.endTime = Date.now();
            
            console.log(`Gra Pamięciowa zakończona w ${MemoryState.totalMoves} ruchach.`);
            
            // Pokaż finałowe statystyki
            showFinalStats('memoryGame');
        }

        /**
         * Funkcja pomocnicza do tasowania tablicy (Fisher-Yates shuffle).
         * @param {Array} array - Tablica do potasowania.
         */
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }


        /*
        =======================================================================
         9. Moduł 9: Tryb Gry - Whac-a-Mole
            - Implementacja na podstawie tutoriali.[28, 29, 43]
            - Logika losowego pojawiania się i znikania ("peep").
        =======================================================================
        */

        // Ustawienia specyficzne dla gry Whac-a-Mole
        const WhacSettings = {
            GAME_DURATION: 30000, // 30 sekund
            MIN_PEEP_TIME: 300,  // ms 
            MAX_PEEP_TIME: 1000, // ms 
            HOLE_COUNT: 9
        };

        // Stan specyficzny dla gry Whac-a-Mole
        const WhacState = {
            holes: [], // Tablica elementów DOM
            lastHole: null, // Zapobiega pojawieniu się w tym samym miejscu [29]
            peepTimeout: null,
            score: 0,
            scoreDisplay: null
        };

        /**
         * Rozpoczyna grę w trybie Whac-a-Mole.
         */
        function startWhacGame() {
            const D = AppState.DOM;
            const C = AppState.currentGame;
            
            C.gameMode = 'whacAMole';
            
            // Przygotowanie interfejsu
            D.gameContainer.innerHTML = `
                <div class="game-start-screen" id="start-screen-whacAMole">
                     <h2 class="game-title">Whac-a-Mole</h2>
                     <div class="whac-stats-live" style="margin-bottom: 1rem;">
                        Wynik: <span id="whac-score" style="font-size: 1.5rem; font-weight: bold; color: var(--accent-color);">0</span>
                     </div>
                     <div class="whac-game-grid" id="whac-grid"></div>
                </div>
            `;
            
            // Zapisz referencje
            const grid = document.getElementById('whac-grid');
            WhacState.scoreDisplay = document.getElementById('whac-score');
            
            // Reset stanu
            C.isActive = true;
            WhacState.score = 0;
            WhacState.lastHole = null;
            clearTimeout(WhacState.peepTimeout);
            WhacState.scoreDisplay.textContent = '0';
            
            // Stwórz dziury
            grid.innerHTML = '';
            WhacState.holes = [];
            for (let i = 0; i < WhacSettings.HOLE_COUNT; i++) {
                const hole = document.createElement('div');
                hole.className = 'whac-hole';
                
                const mole = document.createElement('div');
                mole.className = 'whac-mole';
                mole.addEventListener('click', handleMoleBonk); // Dodaj listener do kreta
                
                hole.appendChild(mole);
                grid.appendChild(hole);
                WhacState.holes.push(hole);
            }
            
            // Rozpocznij grę
            C.startTime = Date.now();
            C.timerInterval = setInterval(updateGameTimer, 100);
            
            // Ustaw timer końca gry
            setTimeout(stopWhacGame, WhacSettings.GAME_DURATION);
            
            // Rozpocznij pojawianie się kretów [29]
            peepMole();
        }

        /**
         * Kończy grę Whac-a-Mole.
         */
        function stopWhacGame() {
            const C = AppState.currentGame;
            if (!C.isActive || C.gameMode !== 'whacAMole') return;
            
            C.isActive = false;
            C.endTime = Date.now();
            clearInterval(C.timerInterval);
            clearTimeout(WhacState.peepTimeout); // Zatrzymaj pojawianie się kretów
            
            // Pokaż finałowe statystyki
            C.hits = WhacState.score; // Zapisz wynik
            showFinalStats('whacAMole');
        }

        /**
         * Funkcja losowego pojawiania się kreta.
         */
        function peepMole() {
            const C = AppState.currentGame;
            if (!C.isActive) return;
            
            // Losowy czas, przez który kret będzie widoczny
            const time = randomTime(WhacSettings.MIN_PEEP_TIME, WhacSettings.MAX_PEEP_TIME);
            // Losowa dziura
            const hole = randomHole(WhacState.holes);
            
            // Pokaż kreta
            hole.classList.add('up');
            
            // Ustaw timer na schowanie kreta
            WhacState.peepTimeout = setTimeout(() => {
                hole.classList.remove('up');
                // Wywołaj następnego kreta, jeśli gra wciąż trwa
                if (C.isActive) {
                    peepMole();
                }
            }, time);
        }

        /**
         * Zwraca losowy czas z podanego przedziału.
         */
        function randomTime(min, max) {
            return Math.round(Math.random() * (max - min) + min);
        }

        /**
         * Zwraca losową dziurę, inną niż poprzednia.[29]
         */
        function randomHole(holes) {
            const idx = Math.floor(Math.random() * holes.length);
            const hole = holes[idx];
            
            if (hole === WhacState.lastHole) {
                // Jeśli to ta sama dziura, spróbuj jeszcze raz
                return randomHole(holes);
            }
            
            WhacState.lastHole = hole;
            return hole;
        }

        /**
         * Obsługuje trafienie kreta.
         * @param {Event} e - Zdarzenie 'click'.
         */
        function handleMoleBonk(e) {
            if (!AppState.currentGame.isActive) return;
            
            // Sprawdź, czy kret był rzeczywiście 'up' (zapobieganie oszustwom)
            const hole = e.target.parentElement;
            if (!hole.classList.contains('up')) {
                return; // Nie trafiono we właściwym momencie
            }
            
            WhacState.score++;
            WhacState.scoreDisplay.textContent = WhacState.score;
            
            // Natychmiast schowaj trafionego kreta
            hole.classList.remove('up');
            
            // Zaktualizuj statystyki na żywo (jeśli chcemy)
            AppState.currentGame.hits = WhacState.score;
            updateLiveStats();
        }


        /*
        =======================================================================
         10. Moduł 10: Logika Ogólna (Start/Stop, Timery, Statystyki)
        =======================================================================
        */

        /**
         * Centralny handler dla przycisków "Start Game".
         * @param {Event} e - Zdarzenie 'click'.
         */
        function handleGameStartClick(e) {
            const gameMode = e.target.dataset.startGame;
            
            // ***************************************************************
            // KRYTYCZNA IMPLEMENTACJA MONETYZACJI (REKLAMA POWIADOMIENIE)
            // Zamiast pokazywać reklamę przy ładowaniu strony (co jest 
            // naruszeniem polityki ), pokazujemy ją po intencji 
            // użytkownika (kliknięcie "Start"), co jest ZGODNE.
            // ***************************************************************
            
            // Pokaż modal reklamowy
            openModal('ad-notification-modal');
            
            // Uruchom grę Z OPÓŹNIENIEM, aby dać czas na wyświetlenie reklamy
            // (Można też uruchomić grę po zamknięciu modala przez użytkownika)
            
            // W tym przypadku uruchamiamy grę natychmiast po zamknięciu modala
            const adModal = AppState.DOM.adNotificationModal;
            
            // Funkcja do uruchomienia gry
            const runGame = () => {
                switch (gameMode) {
                    case 'aimTrainer':
                        startAimTrainer();
                        break;
                    case 'tracking':
                        startTrackingGame();
                        break;
                    case 'whacAMole':
                        startWhacGame();
                        break;
                    // Inne gry (typing, memory) startują inaczej
                }
                // Usuń listener, aby nie wywołać wielokrotnie
                adModal.removeEventListener('close', runGame);
            };
            
            // Dodaj listener, który uruchomi grę po zamknięciu modala
            adModal.addEventListener('close', runGame);
        }

        /**
         * Zatrzymuje dowolną aktywnie działającą grę.
         */
        function stopCurrentGame() {
            const C = AppState.currentGame;
            if (!C.isActive) return;
            
            switch (C.gameMode) {
                case 'aimTrainer':
                    stopAimTrainer();
                    break;
                case 'tracking':
                    stopTrackingGame();
                    break;
                case 'typingTest':
                    stopTypingTest();
                    break;
                case 'memoryGame':
                    // Gra w pamięć nie ma timera, ale kończy się
                    // stopMemoryGame(); // Jest wywoływana wewnętrznie
                    break;
                case 'whacAMole':
                    stopWhacGame();
                    break;
            }
            
            C.isActive = false;
            C.gameMode = null;
            clearInterval(C.timerInterval);
        }

        /**
         * Aktualizuje timer gry w panelu bocznym.
         */
        function updateGameTimer() {
            const C = AppState.currentGame;
            if (!C.isActive || C.startTime === 0) return;
            
            const D = AppState.DOM.liveStats;
            const elapsedTime = (Date.now() - C.startTime) / 1000;
            D.timer.textContent = `${elapsedTime.toFixed(1)}s`;
        }

        /**
         * Aktualizuje statystyki na żywo w panelu bocznym.
         */
        function updateLiveStats() {
            const C = AppState.currentGame;
            const D = AppState.DOM.liveStats;
            
            let accuracy = 0;
            const totalActions = C.hits + C.misses;
            
            if (C.gameMode === 'tracking') {
                // W trybie Tracking, 'hits' to czas na celu, a 'misses' to czas poza
                D.hits.textContent = (C.hits / 1000).toFixed(1) + 's';
                D.misses.textContent = (C.misses / 1000).toFixed(1) + 's';
                if (totalActions > 0) {
                    accuracy = (C.hits / totalActions) * 100;
                }
                D.accuracy.textContent = `${accuracy.toFixed(1)}%`;
                
            } else if (C.gameMode === 'whacAMole') {
                D.hits.textContent = C.hits; // 'hits' to wynik
                D.misses.textContent = 'N/A';
                D.accuracy.textContent = 'N/A';
                
            } else if (C.gameMode === 'aimTrainer') {
                // Dla Aim Trainer
                D.hits.textContent = C.hits;
                D.misses.textContent = C.misses;
                if (totalActions > 0) {
                    accuracy = (C.hits / totalActions) * 100;
                }
                D.accuracy.textContent = `${accuracy.toFixed(1)}%`;
                
            } else {
                // Domyślne zachowanie (np. dla przyszłych gier)
                D.hits.textContent = C.hits;
                D.misses.textContent = C.misses;
                D.accuracy.textContent = 'N/A';
            }
        }

        /**
         * Resetuje statystyki na żywo w panelu bocznym.
         */
        function resetLiveStats() {
            const D = AppState.DOM.liveStats;
            D.hits.textContent = '0';
            D.misses.textContent = '0';
            D.accuracy.textContent = '0%';
            D.timer.textContent = '0.0s';
        }

        /**
         * Oblicza i wyświetla końcowe statystyki w oknie modalnym.
         * @param {string} gameMode - ID zakończonej gry.
         */
        function showFinalStats(gameMode) {
            const C = AppState.currentGame;
            const D = AppState.DOM;
            
            let title = 'Gra Zakończona!';
            let bodyHtml = '';
            let newHighScore = false;
            let scoreData = {};
            
            // Przygotuj statystyki dla każdej gry
            switch (gameMode) {
                case 'aimTrainer':
                    const avgReaction = calculateAverageReactionTime();
                    const finalCps = calculateFinalCPS();
                    const accuracy = (C.hits + C.misses > 0) ? ((C.hits / (C.hits + C.misses)) * 100).toFixed(1) : 0;
                    
                    title = 'Trener Celności: Wyniki';
                    bodyHtml = `
                        <p>Średni czas reakcji: <strong>${avgReaction} ms</strong></p>
                        <p>Trafienia: <strong>${C.hits}</strong></p>
                        <p>Pudła: <strong>${C.misses}</strong></p>
                        <p>Celność: <strong>${accuracy}%</strong></p>
                        <p>Średnie CPS: <strong>${finalCps}</strong></p>
                    `;
                    
                    // Sprawdź najlepszy wynik [32, 33]
                    scoreData = { score: C.hits, reaction: avgReaction };
                    if (!AppState.highScores.aimTrainer || C.hits > AppState.highScores.aimTrainer.score) {
                        newHighScore = true;
                        saveHighScore('aimTrainer', scoreData);
                    }
                    break;
                    
                case 'tracking':
                    const totalTime = C.hits + C.misses;
                    const trackingAccuracy = (totalTime > 0) ? ((C.hits / totalTime) * 100) : 0;
                    
                    title = 'Trening Śledzenia: Wyniki';
                    bodyHtml = `
                        <p>Czas na celu: <strong>${(C.hits / 1000).toFixed(2)} s</strong></p>
                        <p>Czas poza celem: <strong>${(C.misses / 1000).toFixed(2)} s</strong></p>
                        <p>Celność Śledzenia: <strong>${trackingAccuracy.toFixed(2)}%</strong></p>
                    `;
                    
                    scoreData = { score: trackingAccuracy };
                    if (!AppState.highScores.tracking || trackingAccuracy > AppState.highScores.tracking.score) {
                        newHighScore = true;
                        saveHighScore('tracking', scoreData);
                    }
                    break;
                    
                case 'typingTest':
                    const wpm = C.hits; // Przechowywaliśmy WPM w C.hits
                    const errors = C.misses;
                    const typingAccuracy = C.accuracy || 100;
                    
                    title = 'Test Pisania: Wyniki';
                    bodyHtml = `
                        <p>Słowa na Minutę (WPM): <strong>${wpm}</strong></p>
                        <p>Liczba błędów: <strong>${errors}</strong></p>
                        <p>Celność: <strong>${typingAccuracy}%</strong></p>
                    `;
                    
                    scoreData = { wpm: wpm, accuracy: typingAccuracy };
                    if (!AppState.highScores.typingTest || wpm > AppState.highScores.typingTest.wpm) {
                        newHighScore = true;
                        saveHighScore('typingTest', scoreData);
                    }
                    break;
                    
                case 'memoryGame':
                    const moves = C.hits; // Przechowywaliśmy ruchy w C.hits
                    title = 'Gra Pamięciowa: Wyniki';
                    bodyHtml = `
                        <p>Gra ukończona!</p>
                        <p>Liczba ruchów: <strong>${moves}</strong></p>
                    `;
                    
                    scoreData = { moves: moves };
                    if (!AppState.highScores.memoryGame || moves < AppState.highScores.memoryGame.moves) {
                        newHighScore = true;
                        saveHighScore('memoryGame', scoreData);
                    }
                    break;
                    
                case 'whacAMole':
                    const score = C.hits; // Przechowywaliśmy wynik w C.hits
                    title = 'Whac-a-Mole: Wyniki';
                    bodyHtml = `
                        <p>Gra Zakończona!</p>
                        <p>Ostateczny wynik: <strong>${score}</strong></p>
                    `;
                    
                    scoreData = { score: score };
                    if (!AppState.highScores.whacAMole || score > AppState.highScores.whacAMole.score) {
                        newHighScore = true;
                        saveHighScore('whacAMole', scoreData);
                    }
                    break;
            }
            
            // Wypełnij i pokaż modal
            D.statsModalTitle.textContent = title;
            D.statsModalBody.innerHTML = bodyHtml;
            D.statsModalNewHighScore.hidden = !newHighScore;
            
            openModal('stats-modal');
        }

        /*
        =======================================================================
         11. Moduł 11: Inicjalizacja Aplikacji (Główna Pętla)
        =======================================================================
        */

        /**
         * Główna funkcja inicjalizująca aplikację.
         * Wywoływana po załadowaniu drzewa DOM.
         */
        function initializeApp() {
            console.log("Inicjalizacja ReflexCore v1.0...");
            
            // 1. Zmapuj wszystkie elementy DOM
            initializeDOMSelectors();
            
            // 2. Wczytaj ustawienia (motyw, język) z localStorage
            loadSettings();
            
            // 3. Wczytaj najlepsze wyniki
            loadHighScores();
            
            // 4. Uruchom listenery dla panelu ustawień
            initializeSettingsPanel();
            
            // 5. Uruchom listenery dla nawigacji
            initializeNavigation();
            
            // 6. Uruchom listenery dla okien modalnych
            initializeModals();
            
            console.log("Aplikacja gotowa.");
        }

        // Uruchom aplikację po pełnym załadowaniu struktury HTML
        document.addEventListener('DOMContentLoaded', initializeApp);
    </script>

</body>
</html>
